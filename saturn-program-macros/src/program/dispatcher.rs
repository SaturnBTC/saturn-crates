use convert_case::{Case, Casing};
use proc_macro2::{Span, TokenStream};
use quote::quote;
use quote::ToTokens;
use std::hash::{Hash, Hasher};
use syn::LitInt;

use crate::program::analysis::{AnalysisResult, FnInfo};
use crate::program::attr::AttrConfig;

/// Generates the dispatcher + entrypoint implementation for a `#[saturn_program]` module.
/// The returned `TokenStream` already includes the original (potentially modified)
/// module item.
pub fn generate(attr_cfg: &AttrConfig, analysis: &AnalysisResult) -> TokenStream {
    let instruction_path = &attr_cfg.instruction_path;
    let enable_bitcoin_tx = attr_cfg.enable_bitcoin_tx;
    let btc_tx_cfg = &attr_cfg.btc_tx_cfg;

    let module_ident = &analysis.item_mod.ident;

    // ------------------------------------------------------------
    // Build match arms for each instruction handler
    // ------------------------------------------------------------
    let mut match_arms = Vec::<TokenStream>::new();

    for FnInfo { fn_ident, acc_ty } in &analysis.fn_infos {
        let variant_name_str = fn_ident.to_string().to_case(Case::Pascal);
        let variant_ident = syn::Ident::new(&variant_name_str, fn_ident.span());

        let arm = if enable_bitcoin_tx {
            // Build literals for const generics
            let max_inputs_lit = LitInt::new(
                &btc_tx_cfg.max_inputs_to_sign.unwrap().to_string(),
                Span::call_site(),
            );
            let max_mod_lit = LitInt::new(
                &btc_tx_cfg.max_modified_accounts.unwrap().to_string(),
                Span::call_site(),
            );
            let rune_set_path = btc_tx_cfg.rune_set.clone().unwrap();

            quote! {
                #instruction_path :: #variant_ident ( inner ) => {
                    let mut accounts_struct = <#acc_ty as saturn_account_parser::Accounts>::try_accounts(accounts)?;

                    let btc_tx_builder = saturn_account_parser::TxBuilderWrapper::<'info, #max_mod_lit, #max_inputs_lit, #rune_set_path>::default();

                    let mut ctx = saturn_account_parser::Context::new_with_btc_tx(
                        program_id,
                        &mut accounts_struct,
                        &[],
                        btc_tx_builder,
                    );

                    #module_ident :: #fn_ident(&mut ctx, inner)?;

                    // Finalize BTC transaction builder
                    ctx.btc_tx.0.finalize()?;
                }
            }
        } else {
            quote! {
                #instruction_path :: #variant_ident ( inner ) => {
                    let mut accounts_struct = <#acc_ty as saturn_account_parser::Accounts>::try_accounts(accounts)?;

                    let mut ctx = saturn_account_parser::Context::new_simple(
                        program_id,
                        &mut accounts_struct,
                        &[],
                    );
                    #module_ident :: #fn_ident(&mut ctx, inner)?;
                }
            }
        };
        match_arms.push(arm);
    }

    // ------------------------------------------------------------
    // Build a *globally* unique function name to avoid symbol collisions across crates.
    // ------------------------------------------------------------
    let mut hasher = std::collections::hash_map::DefaultHasher::new();
    instruction_path
        .to_token_stream()
        .to_string()
        .hash(&mut hasher);
    let path_hash = hasher.finish();

    let process_ident = syn::Ident::new(
        &format!(
            "__saturn_process_instruction_for_{}_{}",
            module_ident, path_hash
        ),
        Span::call_site(),
    );

    let dispatcher = quote! {
        // Generated by saturn-program-macros
        #[cfg(not(test))]
        arch_program::entrypoint!(#process_ident);

        #[allow(clippy::needless_borrow)]
        pub fn #process_ident<'info>(
            program_id: &arch_program::pubkey::Pubkey,
            accounts: &'info [arch_program::account::AccountInfo<'info>],
            instruction_data: &[u8],
        ) -> Result<(), arch_program::program_error::ProgramError> {
            use arch_program::program_error::ProgramError;
            // Deserialize instruction enum
            let params: #instruction_path = borsh::BorshDeserialize::try_from_slice(instruction_data)
                .map_err(|e| ProgramError::BorshIoError(e.to_string()))?;

            // Dispatch
            match params {
                #( #match_arms )*
            }

            Ok(())
        }
    };

    let item_mod = &analysis.item_mod;

    quote! {
        #item_mod
        #dispatcher
    }
}
