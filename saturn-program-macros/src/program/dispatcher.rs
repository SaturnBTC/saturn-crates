use convert_case::{Case, Casing};
use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::LitInt;

use crate::program::analysis::{AnalysisResult, FnInfo};
use crate::program::attr::AttrConfig;
use syn::{parse_quote, Path};

/// Generates the dispatcher + entrypoint implementation for a `#[saturn_program]` module.
/// The returned `TokenStream` already includes the original (potentially modified)
/// module item.
pub fn generate(attr_cfg: &AttrConfig, analysis: &AnalysisResult) -> TokenStream {
    let module_ident = &analysis.item_mod.ident;

    // The instruction enum will always be `Instr` inside the user's module.
    // Create a unique identifier for the enum that will live in the hidden `__private` module.
    let enum_ident = syn::Ident::new("Instruction", Span::call_site());
    // Path to the generated enum inside the hidden module (avoids name clashes with user types).
    let instruction_path: Path = parse_quote! { crate::#module_ident::__private::#enum_ident };

    // ------------------------------------------------------------
    // If `rune_capacity` is provided, generate a `pub type RuneSet = ..` alias
    // and inject it *inside* the user's module so that handlers can refer to
    // `RuneSet` without a prefix. We build the alias item as a TokenStream and
    // append it to the module's items (AST mutation).
    // ------------------------------------------------------------
    let mut item_mod_mut = analysis.item_mod.clone();
    if let Some(cap) = attr_cfg.btc_tx_cfg.rune_capacity {
        let cap_lit = LitInt::new(&cap.to_string(), Span::call_site());
        let alias_ts: TokenStream = quote! {
            // Generated by saturn-program-macros
            pub type RuneSet = saturn_collections::generic::fixed_set::FixedSet<
                arch_program::rune::RuneAmount,
                #cap_lit
            >;
        };

        // Parse the alias token stream into a syn::Item and push inside module
        if let Some((_brace, ref mut items)) = item_mod_mut.content {
            let alias_item: syn::Item = syn::parse2(alias_ts).expect("failed to parse alias item");
            items.push(alias_item);
        }
    }

    // ------------------------------------------------------------
    // Generate a crate-wide alias that exposes the RuneSet chosen in btc_tx_cfg.
    // This gives other macros (e.g. StateShard derive) a single source of truth.
    // ------------------------------------------------------------
    let rune_alias_ts: Option<TokenStream> = if attr_cfg.enable_bitcoin_tx {
        if let Some(cap) = attr_cfg.btc_tx_cfg.rune_capacity {
            // Rune set defined via capacity â€“ generate a FixedSet alias
            let cap_lit = LitInt::new(&cap.to_string(), Span::call_site());
            Some(quote! {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                pub type __SaturnDefaultRuneSet = saturn_collections::generic::fixed_set::FixedSet<
                    arch_program::rune::RuneAmount,
                    #cap_lit
                >;
            })
        } else if let Some(rune_set_path) = &attr_cfg.btc_tx_cfg.rune_set {
            // Rune set explicitly supplied by the user
            Some(quote! {
                #[doc(hidden)]
                pub type __SaturnDefaultRuneSet = #rune_set_path ;
            })
        } else {
            None
        }
    } else {
        None
    };

    // ------------------------------------------------------------
    // 0. Generate the instruction enum inside a hidden `__private` module to avoid
    //    clashing with user-defined types.
    // ------------------------------------------------------------
    let mut variant_items: Vec<TokenStream> = Vec::new();
    for FnInfo {
        fn_ident,
        second_param_ty,
        ..
    } in &analysis.fn_infos
    {
        let variant_name_str = fn_ident.to_string().to_case(Case::Pascal);
        let variant_ident = syn::Ident::new(&variant_name_str, fn_ident.span());

        let variant_ts: TokenStream = match second_param_ty {
            Some(ty_path) => {
                quote! { #variant_ident ( #ty_path ) }
            }
            None => {
                quote! { #variant_ident }
            }
        };
        variant_items.push(variant_ts);
    }

    // Construct the private module token stream.
    let private_mod_ts: TokenStream = quote! {
        #[doc(hidden)]
        pub mod __private {
            use super::*;
            #[derive(borsh::BorshSerialize, borsh::BorshDeserialize)]
            pub enum #enum_ident {
                #( #variant_items ),*
            }
        }
    };

    if let Some((_brace, ref mut items)) = item_mod_mut.content {
        let private_item: syn::Item = syn::parse2(private_mod_ts).expect("failed to parse private module");
        items.push(private_item);
    }

    // ------------------------------------------------------------
    // Build match arms for each instruction handler
    // ------------------------------------------------------------
    let mut match_arms = Vec::<TokenStream>::new();

    for FnInfo {
        fn_ident,
        acc_ty,
        mod_path,
        second_param_ty,
    } in &analysis.fn_infos
    {
        let variant_name_str = fn_ident.to_string().to_case(Case::Pascal);
        let variant_ident = syn::Ident::new(&variant_name_str, fn_ident.span());

        // Build token stream for nested path `::sub1::sub2` if any
        let nested_path: TokenStream = if mod_path.is_empty() {
            TokenStream::new()
        } else {
            quote! { #( :: #mod_path )* }
        };

        // ------------------------------------------------------------
        // Helper closure: generate the body of a match arm given the
        // name of the bound variable representing the instruction data
        // passed to the handler (either `inner` or `instr`).
        // ------------------------------------------------------------
        let make_arm_body = |bound_ident: &syn::Ident| -> TokenStream {
            if attr_cfg.enable_bitcoin_tx {
                // Build literals for const generics
                let max_inputs_lit = LitInt::new(
                    &attr_cfg.btc_tx_cfg.max_inputs_to_sign.unwrap().to_string(),
                    Span::call_site(),
                );
                let max_mod_lit = LitInt::new(
                    &attr_cfg
                        .btc_tx_cfg
                        .max_modified_accounts
                        .unwrap()
                        .to_string(),
                    Span::call_site(),
                );

                // Use the canonical alias generated above for the RuneSet type
                let rune_set_path: syn::Path =
                    syn::parse_str("crate::__SaturnDefaultRuneSet").expect("internal path parse");

                quote! {
                    let mut accounts_struct = <#acc_ty as saturn_account_parser::Accounts>::try_accounts(accounts)?;

                    let btc_tx_builder = saturn_account_parser::TxBuilderWrapper::<'info, #max_mod_lit, #max_inputs_lit, #rune_set_path>::default();

                    let ctx = saturn_account_parser::Context::new_with_btc_tx(
                        program_id,
                        &mut accounts_struct,
                        &[],
                        btc_tx_builder,
                    );

                    #module_ident #nested_path :: #fn_ident(ctx, #bound_ident)?;
                }
            } else {
                quote! {
                    let mut accounts_struct = <#acc_ty as saturn_account_parser::Accounts>::try_accounts(accounts)?;

                    let ctx = saturn_account_parser::Context::new_simple(
                        program_id,
                        &mut accounts_struct,
                        &[],
                    );
                    #module_ident #nested_path :: #fn_ident(ctx, #bound_ident)?;
                }
            }
        };

        let inner_ident = syn::Ident::new("inner", Span::call_site());
        let body_ts = make_arm_body(&inner_ident);
        let arm: TokenStream = quote! {
            #instruction_path :: #variant_ident ( #inner_ident ) => {
                #body_ts
            }
        };

        match_arms.push(arm);
    }

    // ------------------------------------------------------------
    // Always generate the same dispatcher symbol `process_instruction`.
    // Rely on the Rust/LLVM linker to catch multiple definitions if the crate contains
    // more than one `#[saturn_program]` module
    // ------------------------------------------------------------
    let process_ident = syn::Ident::new("process_instruction", Span::call_site());

    let dispatcher = quote! {
        // When compiling for on-chain use we want exactly **one** public BPF entrypoint symbol.
        // Allow crates to disable the symbol (e.g. when re-used as a dependency for CPI tests)
        // by enabling the Cargo feature `no-entrypoint`.
        #[cfg(all(not(test), not(feature = "no-entrypoint")))]
        arch_program::entrypoint!(#process_ident);

        #[allow(clippy::needless_borrow)]
        pub fn #process_ident<'info>(
            program_id: &arch_program::pubkey::Pubkey,
            accounts: &'info [arch_program::account::AccountInfo<'info>],
            instruction_data: &[u8],
        ) -> Result<(), arch_program::program_error::ProgramError> {
            use arch_program::program_error::ProgramError;
            // Deserialize instruction enum
            let params: #instruction_path = borsh::BorshDeserialize::try_from_slice(instruction_data)
                .map_err(|e| ProgramError::BorshIoError(e.to_string()))?;

            // Dispatch
            match params {
                #( #match_arms )*
            }

            Ok(())
        }
    };

    let item_mod = &item_mod_mut;

    let nested_check_ts: TokenStream = quote! {
        #[allow(dead_code)]
        const _ : () = {
            // Helper to count "::" occurrences
            const fn __count_double_colon(path: &str) -> usize {
                let bytes = path.as_bytes();
                let mut i = 0;
                let mut count = 0;
                while i + 1 < bytes.len() {
                    if bytes[i] == b':' && bytes[i + 1] == b':' {
                        count += 1;
                        i += 1;
                    }
                    i += 1;
                }
                count
            }
            const PATH: &str = concat!(module_path!(), "::", stringify!(#module_ident));
            const COUNT: usize = __count_double_colon(PATH);
            // Emit a *clear* error when the module is nested (COUNT > 1).
            assert!(COUNT <= 1, "#[saturn_program] does not support nested modules; all instruction handlers must live directly inside the annotated module");
        };
    };

    let id_check_ts: TokenStream = quote! {
        #[allow(dead_code)]
        const __SATURN_ENFORCE_ID: () = {
            let _ = &crate::ID;
        };
    };

    quote! {
        #nested_check_ts
        #id_check_ts
        #rune_alias_ts
        #item_mod
        #dispatcher
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use quote::{quote, ToTokens};
    use syn::parse_quote;

    fn dummy_attr_cfg(enable_btc: bool) -> AttrConfig {
        let mut cfg = AttrConfig {
            enable_bitcoin_tx: enable_btc,
            btc_tx_cfg: Default::default(),
        };
        if enable_btc {
            cfg.btc_tx_cfg.max_inputs_to_sign = Some(2);
            cfg.btc_tx_cfg.max_modified_accounts = Some(4);
            cfg.btc_tx_cfg.rune_set = Some(syn::parse_str("crate::RuneSet").unwrap());
        }
        cfg
    }

    fn dummy_analysis(module_name: &str) -> AnalysisResult {
        let mod_ident = syn::Ident::new(module_name, proc_macro2::Span::call_site());
        let item_mod: syn::ItemMod = parse_quote! { mod #mod_ident {} };
        let fn_info = FnInfo {
            fn_ident: syn::Ident::new("handle_transfer", proc_macro2::Span::call_site()),
            acc_ty: syn::parse_str::<syn::Path>("crate::Acc").unwrap(),
            mod_path: vec![],
            second_param_ty: Some(syn::parse_str::<syn::Path>("u8").unwrap()),
        };
        AnalysisResult {
            item_mod,
            fn_infos: vec![fn_info],
        }
    }

    #[test]
    fn generates_simple_dispatcher() {
        let attr_cfg = dummy_attr_cfg(false);
        let analysis = dummy_analysis("my_mod");
        let ts = generate(&attr_cfg, &analysis);
        let ts_str = ts.to_string();
        assert!(
            ts_str.contains("Context :: new_simple"),
            "Should use simple context when BTC disabled"
        );
        assert!(!ts_str.contains("new_with_btc_tx"));
        assert!(ts_str.contains("handle_transfer"));
        assert!(ts_str.contains("my_mod"));
    }

    #[test]
    fn generates_btc_dispatcher() {
        let attr_cfg = dummy_attr_cfg(true);
        let analysis = dummy_analysis("btc_mod");
        let ts = generate(&attr_cfg, &analysis);
        let ts_str = ts.to_string();
        assert!(
            ts_str.contains("new_with_btc_tx"),
            "Should use BTC context when enabled"
        );
        assert!(ts_str.contains("handle_transfer"));
        // Ensure const generics were injected (numbers 2 and 4 from cfg)
        assert!(ts_str.contains("2") && ts_str.contains("4"));
    }

    #[test]
    fn injects_rune_alias_in_btc_dispatcher() {
        let mut cfg = dummy_attr_cfg(true);
        cfg.btc_tx_cfg.rune_capacity = Some(3);
        let analysis = dummy_analysis("alias_mod");
        let ts = generate(&cfg, &analysis);
        let ts_str = ts.to_string();
        assert!(
            ts_str.contains("__SaturnDefaultRuneSet"),
            "Should emit alias type"
        );
    }
}
