use convert_case::{Case, Casing};
use proc_macro2::{Span, TokenStream};
use quote::quote;
use quote::ToTokens;
use std::hash::{Hash, Hasher};
use syn::LitInt;

use crate::program::analysis::{AnalysisResult, FnInfo};
use crate::program::attr::AttrConfig;

/// Generates the dispatcher + entrypoint implementation for a `#[saturn_program]` module.
/// The returned `TokenStream` already includes the original (potentially modified)
/// module item.
pub fn generate(attr_cfg: &AttrConfig, analysis: &AnalysisResult) -> TokenStream {
    let instruction_path = &attr_cfg.instruction_path;
    let enable_bitcoin_tx = attr_cfg.enable_bitcoin_tx;
    let btc_tx_cfg = &attr_cfg.btc_tx_cfg;

    let module_ident = &analysis.item_mod.ident;

    // ------------------------------------------------------------
    // If `rune_capacity` is provided, generate a `pub type RuneSet = ..` alias
    // and inject it *inside* the user's module so that handlers can refer to
    // `RuneSet` without a prefix. We build the alias item as a TokenStream and
    // append it to the module's items (AST mutation).
    // ------------------------------------------------------------
    let mut item_mod_mut = analysis.item_mod.clone();
    if let Some(cap) = btc_tx_cfg.rune_capacity {
        let cap_lit = LitInt::new(&cap.to_string(), Span::call_site());
        let alias_ts: TokenStream = quote! {
            // Generated by saturn-program-macros
            pub type RuneSet = saturn_collections::generic::fixed_set::FixedSet<
                arch_program::rune::RuneAmount,
                #cap_lit
            >;
        };

        // Parse the alias token stream into a syn::Item and push inside module
        if let Some((_brace, ref mut items)) = item_mod_mut.content {
            let alias_item: syn::Item = syn::parse2(alias_ts).expect("failed to parse alias item");
            items.push(alias_item);
        }
    }

    // ------------------------------------------------------------
    // Generate a crate-wide alias that exposes the RuneSet chosen in btc_tx_cfg.
    // This gives other macros (e.g. StateShard derive) a single source of truth.
    // ------------------------------------------------------------
    let rune_alias_ts: Option<TokenStream> = if enable_bitcoin_tx {
        if let Some(cap) = btc_tx_cfg.rune_capacity {
            // Rune set defined via capacity â€“ generate a FixedSet alias
            let cap_lit = LitInt::new(&cap.to_string(), Span::call_site());
            Some(quote! {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                pub type __SaturnDefaultRuneSet = saturn_collections::generic::fixed_set::FixedSet<
                    arch_program::rune::RuneAmount,
                    #cap_lit
                >;
            })
        } else if let Some(rune_set_path) = &btc_tx_cfg.rune_set {
            // Rune set explicitly supplied by the user
            Some(quote! {
                #[doc(hidden)]
                pub type __SaturnDefaultRuneSet = #rune_set_path ;
            })
        } else {
            None
        }
    } else {
        None
    };

    // ------------------------------------------------------------
    // Build match arms for each instruction handler
    // ------------------------------------------------------------
    let mut match_arms = Vec::<TokenStream>::new();

    for FnInfo { fn_ident, acc_ty } in &analysis.fn_infos {
        let variant_name_str = fn_ident.to_string().to_case(Case::Pascal);
        let variant_ident = syn::Ident::new(&variant_name_str, fn_ident.span());

        let arm = if enable_bitcoin_tx {
            // Build literals for const generics
            let max_inputs_lit = LitInt::new(
                &btc_tx_cfg.max_inputs_to_sign.unwrap().to_string(),
                Span::call_site(),
            );
            let max_mod_lit = LitInt::new(
                &btc_tx_cfg.max_modified_accounts.unwrap().to_string(),
                Span::call_site(),
            );

            // Use the canonical alias generated above for the RuneSet type
            let rune_set_path: syn::Path =
                syn::parse_str("crate::__SaturnDefaultRuneSet").expect("internal path parse");

            quote! {
                #instruction_path :: #variant_ident ( inner ) => {
                    let mut accounts_struct = <#acc_ty as saturn_account_parser::Accounts>::try_accounts(accounts)?;

                    let btc_tx_builder = saturn_account_parser::TxBuilderWrapper::<'info, #max_mod_lit, #max_inputs_lit, #rune_set_path>::default();

                    let mut ctx = saturn_account_parser::Context::new_with_btc_tx(
                        program_id,
                        &mut accounts_struct,
                        &[],
                        btc_tx_builder,
                    );

                    #module_ident :: #fn_ident(&mut ctx, inner)?;

                    // Finalize BTC transaction builder
                    ctx.btc_tx.finalize()?;
                }
            }
        } else {
            quote! {
                #instruction_path :: #variant_ident ( inner ) => {
                    let mut accounts_struct = <#acc_ty as saturn_account_parser::Accounts>::try_accounts(accounts)?;

                    let mut ctx = saturn_account_parser::Context::new_simple(
                        program_id,
                        &mut accounts_struct,
                        &[],
                    );
                    #module_ident :: #fn_ident(&mut ctx, inner)?;
                }
            }
        };
        match_arms.push(arm);
    }

    // ------------------------------------------------------------
    // Build a *globally* unique function name to avoid symbol collisions across crates.
    // ------------------------------------------------------------
    let mut hasher = std::collections::hash_map::DefaultHasher::new();
    instruction_path
        .to_token_stream()
        .to_string()
        .hash(&mut hasher);
    let path_hash = hasher.finish();

    let process_ident = syn::Ident::new(
        &format!(
            "__saturn_process_instruction_for_{}_{}",
            module_ident, path_hash
        ),
        Span::call_site(),
    );

    let dispatcher = quote! {
        // Generated by saturn-program-macros
        #[cfg(not(test))]
        arch_program::entrypoint!(#process_ident);

        #[allow(clippy::needless_borrow)]
        pub fn #process_ident<'info>(
            program_id: &arch_program::pubkey::Pubkey,
            accounts: &'info [arch_program::account::AccountInfo<'info>],
            instruction_data: &[u8],
        ) -> Result<(), arch_program::program_error::ProgramError> {
            use arch_program::program_error::ProgramError;
            // Deserialize instruction enum
            let params: #instruction_path = borsh::BorshDeserialize::try_from_slice(instruction_data)
                .map_err(|e| ProgramError::BorshIoError(e.to_string()))?;

            // Dispatch
            match params {
                #( #match_arms )*
            }

            Ok(())
        }
    };

    let item_mod = &item_mod_mut;

    quote! {
        #rune_alias_ts
        #item_mod
        #dispatcher
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use quote::{quote, ToTokens};
    use syn::parse_quote;

    fn dummy_attr_cfg(enable_btc: bool) -> AttrConfig {
        let mut cfg = AttrConfig {
            instruction_path: syn::parse_str::<syn::Path>("crate::ix::Instr").unwrap(),
            enable_bitcoin_tx: enable_btc,
            btc_tx_cfg: Default::default(),
        };
        if enable_btc {
            cfg.btc_tx_cfg.max_inputs_to_sign = Some(2);
            cfg.btc_tx_cfg.max_modified_accounts = Some(4);
            cfg.btc_tx_cfg.rune_set = Some(syn::parse_str("crate::RuneSet").unwrap());
        }
        cfg
    }

    fn dummy_analysis(module_name: &str) -> AnalysisResult {
        let mod_ident = syn::Ident::new(module_name, proc_macro2::Span::call_site());
        let item_mod: syn::ItemMod = parse_quote! { mod #mod_ident {} };
        let fn_info = FnInfo {
            fn_ident: syn::Ident::new("handle_transfer", proc_macro2::Span::call_site()),
            acc_ty: syn::parse_str::<syn::Path>("crate::Acc").unwrap(),
        };
        AnalysisResult {
            item_mod,
            fn_infos: vec![fn_info],
        }
    }

    #[test]
    fn generates_simple_dispatcher() {
        let attr_cfg = dummy_attr_cfg(false);
        let analysis = dummy_analysis("my_mod");
        let ts = generate(&attr_cfg, &analysis);
        let ts_str = ts.to_string();
        assert!(
            ts_str.contains("Context :: new_simple"),
            "Should use simple context when BTC disabled"
        );
        assert!(!ts_str.contains("new_with_btc_tx"));
        assert!(ts_str.contains("handle_transfer"));
        assert!(ts_str.contains("my_mod"));
    }

    #[test]
    fn generates_btc_dispatcher() {
        let attr_cfg = dummy_attr_cfg(true);
        let analysis = dummy_analysis("btc_mod");
        let ts = generate(&attr_cfg, &analysis);
        let ts_str = ts.to_string();
        assert!(
            ts_str.contains("new_with_btc_tx"),
            "Should use BTC context when enabled"
        );
        assert!(ts_str.contains("handle_transfer"));
        // Ensure const generics were injected (numbers 2 and 4 from cfg)
        assert!(ts_str.contains("2") && ts_str.contains("4"));
    }

    #[test]
    fn injects_rune_alias_in_btc_dispatcher() {
        let mut cfg = dummy_attr_cfg(true);
        cfg.btc_tx_cfg.rune_capacity = Some(3);
        let analysis = dummy_analysis("alias_mod");
        let ts = generate(&cfg, &analysis);
        let ts_str = ts.to_string();
        assert!(
            ts_str.contains("__SaturnDefaultRuneSet"),
            "Should emit alias type"
        );
    }
}
