//! # Saturn Account Parser
//!
//! Anchor-style account-parsing utilities for Saturn on-chain programs.
//!
//! This crate provides:
//! * [`Context`] – a typed view over instruction accounts.
//! * The [`codec`] module with Borsh and zero-copy codecs.
//! * Helper functions such as [`get_account`] and [`get_pda_account`] that reduce boiler-plate when validating accounts.
//!
//! Enable the `btc-tx` feature to access the optional Bitcoin transaction builder.

use arch_program::{account::AccountInfo, program_error::ProgramError, pubkey::Pubkey};

use crate::error::ErrorCode;

pub mod codec;
mod to_account_info;
pub use codec::{Account, AccountLoader};
pub mod error;
pub mod tx_builder;
pub use to_account_info::ToAccountInfo;
pub use tx_builder::TxBuilderWrapper;

/// Anchor-style instruction context that bundles the executing program id, a
/// typed view over the accounts (implements [`Accounts`]), and any extra
/// accounts that were passed but not part of the typed struct.
///
/// It is generic over the `Accounts` implementation to keep the same ergonomics
/// as Anchor while staying flexible for Saturn programs.
pub struct Context<'a, 'b, 'c, 'info, T: Accounts<'info>, TxBuilder = ()> {
    /// Public key of the program that is currently executing.
    pub program_id: &'a Pubkey,

    /// A **typed view** over the instruction's accounts (the struct that
    /// derives `Accounts`).
    pub accounts: &'b mut T,

    /// Any extra accounts that were supplied but not listed in the `Accounts`
    /// struct.
    pub remaining_accounts: &'c [AccountInfo<'info>],

    /// Optional Bitcoin transaction builder available when the program opts in
    /// by providing a `btc_tx_cfg(...)` section in the `#[saturn_program]` attribute.
    pub btc_tx: TxBuilder,
}

// Convenience constructors
impl<'a, 'b, 'c, 'info, T: Accounts<'info>> Context<'a, 'b, 'c, 'info, T> {
    /// Same fields as before – no Bitcoin builder.
    pub fn new_simple(
        program_id: &'a Pubkey,
        accounts: &'b mut T,
        remaining_accounts: &'c [AccountInfo<'info>],
    ) -> Self {
        Self {
            program_id,
            accounts,
            remaining_accounts,
            btc_tx: (),
        }
    }
}

impl<'a, 'b, 'c, 'info, T: Accounts<'info>, TxBuilder> Context<'a, 'b, 'c, 'info, T, TxBuilder> {
    /// Constructor used by the macro when a Bitcoin transaction builder is provided.
    pub fn new_with_btc_tx(
        program_id: &'a Pubkey,
        accounts: &'b mut T,
        remaining_accounts: &'c [AccountInfo<'info>],
        btc_tx: TxBuilder,
    ) -> Self {
        Self {
            program_id,
            accounts,
            remaining_accounts,
            btc_tx,
        }
    }
}

/// Trait implemented by every struct generated by `#[derive(Accounts)]`.
///
/// Implementors convert the raw `&[AccountInfo]` slice provided to every
/// on-chain instruction into a strongly-typed container while performing all
/// necessary runtime checks (signer / writable flags, ownership, PDA validity,
/// etc.).
pub trait Accounts<'a>: Sized {
    /// Attempts to create `Self` from the given account slice.
    ///
    /// # Errors
    /// Returns an appropriate [`ProgramError`] when validation fails.
    fn try_accounts(accounts: &'a [AccountInfo<'a>]) -> Result<Self, ProgramError>;
}

/// Retrieves the account at position `index` from `accounts` and optionally
/// verifies its signer / writable flags and public key.
///
/// This helper centralises repetitive validation logic and should be preferred
/// over manual indexing.
pub fn get_account<'a>(
    accounts: &'a [AccountInfo<'a>],
    index: usize,
    is_signer: Option<bool>,
    is_writable: Option<bool>,
    key: Option<Pubkey>,
) -> Result<&'a AccountInfo<'a>, ProgramError> {
    // msg!("get_account: {}", index);

    let acc = accounts
        .get(index)
        .ok_or(ProgramError::NotEnoughAccountKeys)?;

    if let Some(acc_is_signer) = is_signer {
        if acc.is_signer != acc_is_signer {
            return Err(ProgramError::Custom(
                ErrorCode::IncorrectIsSignerFlag.into(),
            ));
        }
    }

    if let Some(acc_is_writable) = is_writable {
        if acc.is_writable != acc_is_writable {
            return Err(ProgramError::Custom(
                ErrorCode::IncorrectIsWritableFlag.into(),
            ));
        }
    }

    if let Some(key) = key {
        if acc.key != &key {
            return Err(ProgramError::Custom(
                crate::error::ErrorCode::InvalidAccountKey.into(),
            ));
        }
    }

    Ok(acc)
}

/// Same as [`get_account`] but additionally checks that the account is a PDA
/// derived from `seeds` with the provided `program_id`.
pub fn get_pda_account<'a>(
    accounts: &'a [AccountInfo<'a>],
    index: usize,
    is_signer: Option<bool>,
    is_writable: Option<bool>,
    seeds: &[&[u8]],
    program_id: &Pubkey,
) -> Result<&'a AccountInfo<'a>, ProgramError> {
    // First, retrieve the desired account while validating signer / writable flags
    let acc = get_account(accounts, index, is_signer, is_writable, None)?;

    // Enforce the same seed-count limit as the runtime for consistency.
    if seeds.len() > arch_program::pubkey::MAX_SEEDS {
        return Err(ProgramError::InvalidSeeds);
    }

    // Derive the expected PDA address from the provided seeds
    let (expected_key, _bump) = Pubkey::find_program_address(seeds, program_id);

    if acc.key != &expected_key {
        return Err(ProgramError::Custom(ErrorCode::InvalidPda.into()));
    }

    Ok(acc)
}

/// Variant of [`get_pda_account`] that appends a little-endian `u16` index to
/// `base_seeds`, enabling deterministic PDA namespaces.
pub fn get_indexed_pda_account<'a>(
    accounts: &'a [AccountInfo<'a>],
    index: usize,
    is_signer: Option<bool>,
    is_writable: Option<bool>,
    base_seeds: &[&[u8]],
    idx: u16,
    program_id: &Pubkey,
) -> Result<&'a AccountInfo<'a>, ProgramError> {
    // Retrieve the account reference first (signer / writable flags checked)
    let acc = get_account(accounts, index, is_signer, is_writable, None)?;

    // Encode the dynamic index as LE bytes (2-byte little-endian)
    let idx_bytes = idx.to_le_bytes();

    // -----------------------------------------------------------------------------------------------------------------
    // Build the full seed slice **without** performing a heap allocation.
    // We do this by copying the provided `base_seeds` into a fixed-size stack array and appending `idx_bytes`.
    // The Solana (and Arch) runtime caps the number of seeds for PDA derivation, which is exposed via
    // `arch_program::pubkey::MAX_SEEDS`. We enforce that limit and use it as the array length.
    // -----------------------------------------------------------------------------------------------------------------
    const MAX_SEEDS: usize = arch_program::pubkey::MAX_SEEDS;

    // Return an error if the caller provides more seeds than allowed once we append the index.
    let total_seeds = base_seeds.len() + 1; // +1 for `idx_bytes`
    if total_seeds > MAX_SEEDS {
        return Err(ProgramError::InvalidSeeds);
    }

    // A helper const for an empty slice so we can easily initialise the array.
    const EMPTY_SLICE: &[u8] = &[];

    // Fixed-size stack array that will temporarily hold all seed references. Initialised with empty slices.
    let mut seed_buf: [&[u8]; MAX_SEEDS] = [EMPTY_SLICE; MAX_SEEDS];

    // Copy the user's seeds into the buffer.
    seed_buf[..base_seeds.len()].copy_from_slice(base_seeds);
    // Append the LE-encoded `idx`.
    seed_buf[base_seeds.len()] = &idx_bytes;

    // Slice the buffer down to the actual number of seeds we filled.
    let seeds_slice = &seed_buf[..total_seeds];

    // Derive PDA from seeds and compare.
    let (expected_key, _bump) = Pubkey::find_program_address(seeds_slice, program_id);
    if acc.key != &expected_key {
        return Err(ProgramError::Custom(ErrorCode::InvalidPda.into()));
    }

    Ok(acc)
}
